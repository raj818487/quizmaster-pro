import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { AuthService } from '../../../core/auth.service';
import { Router, ActivatedRoute } from '@angular/router';
import { QuizService } from '../../../core/quiz.service';
import { ToastService } from '../../../core/toast.service';
import { Quiz, Question, User } from '../../../core/models';
import { ToastComponent } from '../../../shared/toast/toast.component';
import { SplitPipe } from '../../../shared/pipes/split.pipe';

@Component({
  selector: 'app-quiz-management',
  standalone: true,
  imports: [CommonModule, FormsModule, ToastComponent, SplitPipe],
  templateUrl: './quiz-management.component.html',
  styleUrls: ['./quiz-management.component.scss'],
})
export class QuizManagementComponent implements OnInit {
  // Quiz Management Properties
  userQuizzes: Quiz[] = [];
  currentUser: User | null = null;
  currentQuestion: Partial<Question> = {
    text: '',
    type: 'multiple_choice',
    correct_answer: '',
    options: ['', '', '', ''],
    points: 10,
    quiz_id: 0,
  };
  
  // Helper method to check if an object is an array
  isArray(obj: any): boolean {
    return Array.isArray(obj);
  }
  
  // Helper methods for question editing
  getCurrentQuestionOptionsAsArray(): string[] {
    if (this.currentQuestion.options) {
      return Array.isArray(this.currentQuestion.options) 
        ? this.currentQuestion.options
        : typeof this.currentQuestion.options === 'string'
          ? JSON.parse(this.currentQuestion.options as string)
          : [];
    }
    return [];
  }
  
  onQuestionTypeChange(): void {
    const type = this.currentQuestion.type;
    if (type === 'multiple_choice') {
      if (!this.currentQuestion.options || !Array.isArray(this.currentQuestion.options)) {
        this.currentQuestion.options = ['', '', '', ''];
      }
    } else if (type === 'true_false') {
      this.currentQuestion.options = ['True', 'False'];
      if (!['True', 'False'].includes(this.currentQuestion.correct_answer || '')) {
        this.currentQuestion.correct_answer = 'True';
      }
    } else {
      // Text type
      this.currentQuestion.options = [];
      this.currentQuestion.correct_answer = '';
    }
  }
  
  addOption(): void {
    if (Array.isArray(this.currentQuestion.options)) {
      (this.currentQuestion.options as string[]).push('');
    }
  }
  
  removeOption(index: number): void {
    if (Array.isArray(this.currentQuestion.options)) {
      const options = this.currentQuestion.options as string[];
      // Don't remove if it would leave fewer than 2 options
      if (options.length > 2) {
        // If removing the correct answer, reset it
        if (this.currentQuestion.correct_answer === options[index]) {
          this.currentQuestion.correct_answer = '';
        }
        options.splice(index, 1);
      }
    }
  }
  
  onOptionChange(index: number, event: Event): void {
    const input = event.target as HTMLInputElement;
    if (Array.isArray(this.currentQuestion.options)) {
      (this.currentQuestion.options as string[])[index] = input.value;
    }
  }

  newQuiz: Partial<Quiz> = {
    title: '',
    description: '',
    is_public: false,
  };

  newQuestion: Partial<Question> = {
    text: '',
    type: 'multiple_choice',
    correct_answer: '',
    options: ['', '', '', ''],
    points: 10,
    quiz_id: 0,
  };

  editingQuiz: Quiz | null = null;
  editingQuestion: Question | null = null;
  showNewQuizForm: boolean = false;
  showNewQuestionForm: boolean = false;
  selectedQuiz: Quiz | null = null;
  selectedQuizQuestions: Question[] = [];
  loadingQuestions: boolean = false;
  
  // Helper for tracking in ngFor loops
  trackByIndex(index: number): number {
    return index;
  }

  constructor(
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute,
    private quizService: QuizService,
    private toastService: ToastService
  ) {}

  ngOnInit(): void {
    this.loadUserQuizzes();
    this.currentUser = this.authService.getCurrentUser();
    
    // Check for fragment to show create quiz form
    this.route.fragment.subscribe(fragment => {
      if (fragment === 'create-quiz') {
        this.showNewQuizForm = true;
      }
    });
  }

  async loadUserQuizzes(): Promise<void> {
    try {
      const currentUser = this.authService.getCurrentUser();
      if (currentUser?.id) {
        this.userQuizzes = await this.quizService.getUserQuizzes(
          currentUser.id
        );
      }
    } catch (error) {
      console.error('Error loading quizzes:', error);
      this.toastService.error('Failed to load quizzes');
    }
  }

  // Quiz Management Methods
  async createQuiz(): Promise<void> {
    try {
      if (!this.newQuiz.title || !this.newQuiz.description) {
        this.toastService.error('Please fill in all required fields');
        return;
      }

      const currentUser = this.authService.getCurrentUser();
      if (!currentUser?.id) {
        this.toastService.error('User not authenticated');
        return;
      }

      const result = await this.quizService.createQuiz(
        {
          title: this.newQuiz.title,
          description: this.newQuiz.description,
          created_by: currentUser.id,
        },
        [],
        currentUser.id
      );

      if (result.success && result.quiz) {
        this.userQuizzes.push(result.quiz);
        this.resetNewQuiz();
        this.showNewQuizForm = false;
        this.toastService.success('Quiz created successfully!');
      } else {
        this.toastService.error(result.message);
      }
    } catch (error) {
      console.error('Error creating quiz:', error);
      this.toastService.error('Failed to create quiz');
    }
  }

  async updateQuiz(): Promise<void> {
    if (!this.editingQuiz) return;

    try {
      const currentUser = this.authService.getCurrentUser();
      if (!currentUser?.id) {
        this.toastService.error('User not authenticated');
        return;
      }

      const result = await this.quizService.updateQuiz(
        this.editingQuiz.id!,
        this.editingQuiz,
        currentUser.id
      );

      if (result.success) {
        const index = this.userQuizzes.findIndex(
          (q) => q.id === this.editingQuiz!.id
        );
        if (index !== -1) {
          this.userQuizzes[index] = { ...this.editingQuiz };
        }
        this.editingQuiz = null;
        this.toastService.success('Quiz updated successfully!');
      } else {
        this.toastService.error(result.message);
      }
    } catch (error) {
      console.error('Error updating quiz:', error);
      this.toastService.error('Failed to update quiz');
    }
  }

  async deleteQuiz(quiz: Quiz): Promise<void> {
    if (!window.confirm(`Are you sure you want to delete "${quiz.title}"?`)) {
      return;
    }

    try {
      const currentUser = this.authService.getCurrentUser();
      if (!currentUser?.id) {
        this.toastService.error('User not authenticated');
        return;
      }

      const result = await this.quizService.deleteQuiz(
        quiz.id!,
        currentUser.id
      );

      if (result.success) {
        this.userQuizzes = this.userQuizzes.filter((q) => q.id !== quiz.id);
        if (this.selectedQuiz?.id === quiz.id) {
          this.selectedQuiz = null;
          this.selectedQuizQuestions = [];
        }
        this.toastService.success('Quiz deleted successfully!');
      } else {
        this.toastService.error(result.message);
      }
    } catch (error) {
      console.error('Error deleting quiz:', error);
      this.toastService.error('Failed to delete quiz');
    }
  }

  selectQuiz(quiz: Quiz): void {
    this.selectedQuiz = quiz;
    this.loadQuizQuestions();
  }
  
  editQuiz(quiz: Quiz): void {
    this.editingQuiz = { ...quiz };
  }

  resetNewQuiz(): void {
    this.newQuiz = {
      title: '',
      description: '',
      is_public: false,
    };
  }

  async loadQuizQuestions(): Promise<void> {
    if (!this.selectedQuiz?.id) return;

    this.loadingQuestions = true;

    try {
      this.selectedQuizQuestions = await this.quizService.getQuestions(
        this.selectedQuiz.id
      );
    } catch (error) {
      console.error('Error loading questions:', error);
      this.toastService.error('Failed to load questions');
    } finally {
      this.loadingQuestions = false;
    }
  }

  // Helper function is already defined above

  // Question Management Methods
  async createQuestion(): Promise<void> {
    if (!this.selectedQuiz) return;

    try {
      if (!this.currentQuestion.text || !this.currentQuestion.correct_answer) {
        this.toastService.error('Please fill in all required fields');
        return;
      }

      const currentUser = this.authService.getCurrentUser();
      if (!currentUser?.id) {
        this.toastService.error('User not authenticated');
        return;
      }

      // Validate multiple choice options
      if (this.currentQuestion.type === 'multiple_choice') {
        const optionsArray = Array.isArray(this.currentQuestion.options)
          ? this.currentQuestion.options
          : [];
        const nonEmptyOptions = optionsArray.filter(
          (opt: string) => opt.trim() !== ''
        );
        if (nonEmptyOptions.length < 2) {
          this.toastService.error(
            'Multiple choice questions need at least 2 options'
          );
          return;
        }
        if (!nonEmptyOptions.includes(this.currentQuestion.correct_answer || '')) {
          this.toastService.error('Correct answer must be one of the options');
          return;
        }
        this.currentQuestion.options = nonEmptyOptions;
      }

      const result = await this.quizService.addQuestion(
        this.selectedQuiz.id!,
        {
          text: this.currentQuestion.text!,
          type: this.currentQuestion.type!,
          correct_answer: this.currentQuestion.correct_answer!,
          options: this.currentQuestion.options,
          points: this.currentQuestion.points,
        },
        currentUser.id
      );

      if (result.success) {
        this.resetNewQuestion();
        this.showNewQuestionForm = false;
        this.toastService.success('Question added successfully!');
        // Reload questions to show the new question
        await this.loadQuizQuestions();
      } else {
        this.toastService.error(result.message);
      }
    } catch (error) {
      console.error('Error creating question:', error);
      this.toastService.error('Failed to create question');
    }
  }

  async updateQuestion(): Promise<void> {
    if (!this.editingQuestion) return;

    try {
      const currentUser = this.authService.getCurrentUser();
      if (!currentUser?.id) {
        this.toastService.error('User not authenticated');
        return;
      }
      
      // Update the editing question with current values
      const updatedQuestion = {
        ...this.editingQuestion,
        text: this.currentQuestion.text,
        type: this.currentQuestion.type,
        correct_answer: this.currentQuestion.correct_answer,
        options: this.currentQuestion.options,
        points: this.currentQuestion.points
      };

      const result = await this.quizService.updateQuestion(
        this.editingQuestion.id!,
        updatedQuestion,
        currentUser.id
      );

      if (result.success) {
        this.editingQuestion = null;
        this.showNewQuestionForm = false;
        this.toastService.success('Question updated successfully!');
        // Reload questions to show the updated question
        await this.loadQuizQuestions();
      } else {
        this.toastService.error(result.message);
      }
    } catch (error) {
      console.error('Error updating question:', error);
      this.toastService.error('Failed to update question');
    }
  }

  async deleteQuestion(questionId: number): Promise<void> {
    if (!confirm('Are you sure you want to delete this question?')) return;

    try {
      const currentUser = this.authService.getCurrentUser();
      if (!currentUser?.id) {
        this.toastService.error('User not authenticated');
        return;
      }

      const result = await this.quizService.deleteQuestion(
        questionId,
        currentUser.id
      );

      if (result.success) {
        this.toastService.success('Question deleted successfully!');
        // Reload questions to remove the deleted question
        await this.loadQuizQuestions();
      } else {
        this.toastService.error(result.message);
      }
    } catch (error) {
      console.error('Error deleting question:', error);
      this.toastService.error('Failed to delete question');
    }
  }

  resetNewQuestion(): void {
    this.newQuestion = {
      text: '',
      type: 'multiple_choice',
      correct_answer: '',
      options: ['', '', '', ''],
      points: 10,
      quiz_id: 0,
    };
    
    this.currentQuestion = {
      text: '',
      type: 'multiple_choice',
      correct_answer: '',
      options: ['', '', '', ''],
      points: 10,
      quiz_id: 0,
    };
  }

  editQuestion(question: Question): void {
    this.editingQuestion = { ...question };
    this.currentQuestion = { ...question };
    this.showNewQuestionForm = true;
  }

  cancelEdit(): void {
    this.editingQuiz = null;
    this.editingQuestion = null;
  }
  
  cancelQuestionEdit(): void {
    this.showNewQuestionForm = false;
    this.editingQuestion = null;
    this.resetNewQuestion();
  }
  
  saveQuestion(): void {
    if (this.editingQuestion) {
      this.updateQuestion();
    } else {
      this.createQuestion();
    }
  }

  goBackToDashboard(): void {
    this.router.navigate(['/admin']);
  }
  
  // Helper method to get options as array
  getOptionsAsArray(options: string[] | string | undefined): string[] {
    if (!options) return [];
    if (Array.isArray(options)) return options;
    try {
      return JSON.parse(options);
    } catch {
      return [];
    }
  }
}
